
package ElasticLoadBalance_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/*', "\n";
   print ' * Copyright (C) 2015 International Business Machines Corporation. ', "\n";
   print ' * All Rights Reserved.', "\n";
   print ' */', "\n";
   print "\n";
       use ElasticLoadBalanceCommon;
       ElasticLoadBalanceCommon::verify($model);
   
       # params that require no compile-time checks
       my $bufferSize = $model->getParameterByName("bufferSize");
       my $elastic = $model->getParameterByName("elastic");
       my $rapidScaling = $model->getParameterByName("rapidScaling");
   
       $bufferSize = $bufferSize->getValueAt(0)->getCppExpression();
       $elastic = $elastic ? $elastic->getValueAt(0)->getCppExpression(): "true";
       $rapidScaling = $rapidScaling ? $rapidScaling->getValueAt(0)->getCppExpression(): "false";
   
       # params that require compile-time checks
       my $congestionToleranceParam = $model->getParameterByName("congestionTolerance");
       my $throughputToleranceParam = $model->getParameterByName("throughputTolerance");
       my $measurePeriodParam = $model->getParameterByName("measurePeriod");
       my $initialActivePortsParam = $model->getParameterByName("initialActivePorts");
   
       my $congestionTolerance = $congestionToleranceParam ? $congestionToleranceParam->getValueAt(0)->getCppExpression(): "0.5";
       my $throughputTolerance = $throughputToleranceParam ? $throughputToleranceParam->getValueAt(0)->getCppExpression(): "0.05";
       my $measurePeriod = $measurePeriodParam ? $measurePeriodParam->getValueAt(0)->getCppExpression(): "5";
   
       # we need to remember if the user specified initial threads because if they did, we always use that; 
       # if not, then we have different behavior depending on if elastic was specified or not
       my $initialActivePortsSpecified = 0;
       if ($initialActivePortsParam) {
           $initialActivePortsSpecified = 1;
       }
       my $initialActivePorts = $initialActivePortsParam ? $initialActivePortsParam->getValueAt(0)->getCppExpression(): "1";
   
       if ($congestionToleranceParam) {
           my $congestion = SPL::CodeGen::extractPerlValue($congestionToleranceParam->getValueAt(0)->getCppExpression(),
                                                              $congestionToleranceParam->getValueAt(0)->getSPLType());
           if ($congestion < 0.0 || $congestion > 1.0) {
               SPL::CodeGen::exitln("The congestionTolerance param must be a value between 0.0 and 1.0.", 
                                    $congestionToleranceParam->getSourceLocation()) 
           }
       }
   
       if ($throughputToleranceParam) {
           my $throughput = SPL::CodeGen::extractPerlValue($throughputToleranceParam->getValueAt(0)->getCppExpression(),
                                                              $throughputToleranceParam->getValueAt(0)->getSPLType());
           if ($throughput < 0.0 || $throughput > 1.0) {
               SPL::CodeGen::exitln("The throughputTolerance param must be a value between 0.0 and 1.0.", 
                                    $throughputToleranceParam->getSourceLocation()) 
           }
       }
   
       if ($measurePeriodParam) {
           my $measure = SPL::CodeGen::extractPerlValue($measurePeriodParam->getValueAt(0)->getCppExpression(),
                                                           $measurePeriodParam->getValueAt(0)->getSPLType());
           if ($measure <= 0) {
               SPL::CodeGen::exitln("The measurePeriod param must be greater than 0.", 
                                    $measurePeriodParam->getSourceLocation()) 
           }
       }
   
       if ($initialActivePortsParam) {
           my $initial = SPL::CodeGen::extractPerlValue($initialActivePortsParam->getValueAt(0)->getCppExpression(), 
                                                        $initialActivePortsParam->getValueAt(0)->getSPLType());
           if ($initial == 0) {
               SPL::CodeGen::exitln("The initialActivePorts param must be greater than 0." . " ",
                                    $initialActivePortsParam->getSourceLocation()) 
           }
           if ($initial > $model->getNumberOfOutputPorts()) {
               SPL::CodeGen::exitln("The initialActivePorts param must not be greater than the number of output ports.", 
                                    $initialActivePortsParam->getSourceLocation()) 
           }
       }
   print "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '#include <SPL/Runtime/Utility/BackoffSpinner.h>', "\n";
   print '#include <SPL/Runtime/Utility/LogTraceMessage.h>', "\n";
   print '#include <SPL/Runtime/Operator/OperatorMetrics.h>', "\n";
   print "\n";
   print '#include <limits>', "\n";
   print '#include <cassert>', "\n";
   print '#include <cmath>', "\n";
   print '#include <iostream>', "\n";
   print '#include <memory.h>', "\n";
   print "\n";
   print 'using namespace std;', "\n";
   print "\n";
   print 'const double CONGESTION_TOLERANCE = ';
   print $congestionTolerance;
   print ';', "\n";
   print 'const double THROUGHPUT_TOLERANCE = ';
   print $throughputTolerance;
   print ';', "\n";
   print 'const int64_t MEASURE_PERIOD = ';
   print $measurePeriod;
   print ';', "\n";
   print 'const bool RAPID_SCALING = ';
   print $rapidScaling;
   print ';', "\n";
   print 'const uint32_t INITIAL_THREADS = ';
   print $initialActivePorts;
   print ';', "\n";
   print 'const bool INITIAL_THREADS_SPECIFIED = ';
   print $initialActivePortsSpecified;
   print ';', "\n";
   print 'const bool ELASTIC = ';
   print $elastic;
   print ';', "\n";
   print 'const int32_t NOISE_LIMIT = 1;', "\n";
   print "\n";
   print 'class AdaptCallback {', "\n";
   print 'public:', "\n";
   print '    AdaptCallback(MY_OPERATOR& op): _operator(op) {}', "\n";
   print '    void operator()() { _operator.adapt(); }', "\n";
   print 'private:', "\n";
   print '    MY_OPERATOR& _operator;', "\n";
   print '};', "\n";
   print "\n";
   print 'template <class Callback>', "\n";
   print 'class AlarmThread: public Thread {', "\n";
   print 'public:', "\n";
   print '    AlarmThread(volatile bool& s, time_t p, Callback c):', "\n";
   print '        _stop(s), _period(p), _callback(c)', "\n";
   print '    {}', "\n";
   print "\n";
   print '    void* run(void*)', "\n";
   print '    {', "\n";
   print '        while (!_stop) {', "\n";
   print '            timespec request, remain;', "\n";
   print '            request.tv_sec = _period;', "\n";
   print '            request.tv_nsec =  0;', "\n";
   print "\n";
   print '            int ret = -1;', "\n";
   print '            while (ret == -1) {', "\n";
   print '                ret = nanosleep(&request, &remain);', "\n";
   print '                if (ret == -1 && errno != EINTR) {', "\n";
   print '                    SPCDBG(L_ERROR, "nanosleep had a non-EINTR error: " << strerror(errno), SPL_PE_DBG);', "\n";
   print '                }', "\n";
   print '                request = remain;', "\n";
   print '            }', "\n";
   print "\n";
   print '            _callback();', "\n";
   print '        }', "\n";
   print "\n";
   print '        return NULL;', "\n";
   print '    }', "\n";
   print "\n";
   print 'private:', "\n";
   print '    volatile bool& _stop;', "\n";
   print '    time_t _period;', "\n";
   print '    Callback _callback;', "\n";
   print '};', "\n";
   print "\n";
   print 'class ElasticAdaptation {', "\n";
   print 'public:', "\n";
   print '    ElasticAdaptation(bool scaling, double sensitivity, int32_t max);', "\n";
   print '    ~ElasticAdaptation();', "\n";
   print '    void init(uint32_t numChannels);       ', "\n";
   print '    int32_t getNumberOfChannels(bool congested, double throughput);     ', "\n";
   print "\n";
   print 'private:', "\n";
   print '    struct ChannelInfo {', "\n";
   print '        double lastThroughput;', "\n";
   print '        double firstThroughput;', "\n";
   print '        bool lastCongested;', "\n";
   print '        int64_t lastTime;', "\n";
   print '        bool trusted;', "\n";
   print '    };', "\n";
   print "\n";
   print '    enum LoadChange {LessLoad, MoreLoad, PotentialNoise, UnknownLoadChange};', "\n";
   print "\n";
   print '    int64_t _time; // logical adaptation time', "\n";
   print '    int32_t _currentLevel;   ', "\n";
   print '    int32_t _noiseDetector;', "\n";
   print '    int32_t _maxLevel;', "\n";
   print '    ChannelInfo* _channelInfos;', "\n";
   print '    bool _rapidScaling; ', "\n";
   print '    double _changeSensitivity;', "\n";
   print "\n";
   print '    int32_t mapNumChannelsToChannelLevel(int32_t numChannelsPhysical);', "\n";
   print '    int32_t mapChannelLevelToNumChannels(int32_t channelLevel);', "\n";
   print '    LoadChange checkForChangeInLoadBasedOnCongestion(bool congested);', "\n";
   print '    LoadChange checkForChangeInLoadBasedOnThroughput(double throughput);', "\n";
   print '    LoadChange pingNoiseDetector(LoadChange direction);', "\n";
   print '    bool improvementTrendBelow(double throughput);', "\n";
   print '    bool improvementTrendAbove(double throughput);', "\n";
   print '    bool trustBelow();', "\n";
   print '    bool trustAbove();', "\n";
   print '    void untrustOtherData(double throughput);', "\n";
   print '};', "\n";
   print "\n";
   print 'ElasticAdaptation::ElasticAdaptation(bool scaling, double sensitivity, int32_t max): ', "\n";
   print '    _maxLevel(max),', "\n";
   print '    _channelInfos(new ChannelInfo[_maxLevel]), _rapidScaling(scaling), ', "\n";
   print '    _changeSensitivity(sensitivity)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_INFO, "ElasticAdaptation: max level: " << _maxLevel, SPL_OPER_DBG);', "\n";
   print '    SPLAPPTRC(L_INFO, "ElasticAdaptation: rapid scaling: " << (_rapidScaling ? "on": "off"), SPL_OPER_DBG);', "\n";
   print '    SPLAPPTRC(L_INFO, "ElasticAdaptation: throughput change tolerance: " << _changeSensitivity, SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'ElasticAdaptation::~ElasticAdaptation()', "\n";
   print '{', "\n";
   print '    delete _channelInfos;', "\n";
   print '}', "\n";
   print "\n";
   print 'static double inf() ', "\n";
   print '{ ', "\n";
   print '    return std::numeric_limits<double>::infinity(); ', "\n";
   print '}', "\n";
   print "\n";
   print 'static double nan() ', "\n";
   print '{ ', "\n";
   print '    return std::numeric_limits<double>::quiet_NaN();', "\n";
   print '}', "\n";
   print "\n";
   print 'void ElasticAdaptation::init(uint32_t numChannels)', "\n";
   print '{', "\n";
   print '    _currentLevel = mapNumChannelsToChannelLevel(numChannels);', "\n";
   print '    _noiseDetector = NOISE_LIMIT;', "\n";
   print '    for(int32_t i=0; i<_maxLevel; ++i) {', "\n";
   print '        ChannelInfo & info = _channelInfos[i];', "\n";
   print '        info.firstThroughput = nan();', "\n";
   print '        info.lastThroughput = inf();', "\n";
   print '        info.lastCongested = true;', "\n";
   print '        info.lastTime = -1; ', "\n";
   print '        info.trusted = false;', "\n";
   print '    }		 	', "\n";
   print '    _time = 0;', "\n";
   print '}', "\n";
   print "\n";
   print 'int32_t ElasticAdaptation::mapNumChannelsToChannelLevel(int32_t numChannels) ', "\n";
   print '{', "\n";
   print '    if (_rapidScaling) {', "\n";
   print '        for (int32_t i=0; true; ++i) {', "\n";
   print '            if (mapChannelLevelToNumChannels(i)==numChannels)', "\n";
   print '                return i;', "\n";
   print '        }', "\n";
   print '        assert(!"cannot happen");', "\n";
   print '        return 0;', "\n";
   print '    } else {', "\n";
   print '        return numChannels - 1;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'int32_t ElasticAdaptation::mapChannelLevelToNumChannels(int32_t channelLevel) ', "\n";
   print '{', "\n";
   print '    if (_rapidScaling) {', "\n";
   print '        int32_t i = channelLevel + 1;', "\n";
   print '        return (int) (0.5 + ::pow(2.0, (0.5 * i)));', "\n";
   print '    } else {', "\n";
   print '        return channelLevel + 1;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'ElasticAdaptation::LoadChange ElasticAdaptation::checkForChangeInLoadBasedOnCongestion(bool congested)', "\n";
   print '{', "\n";
   print '    ChannelInfo * cci = &_channelInfos[_currentLevel];', "\n";
   print '    ChannelInfo * nci = (_currentLevel<_maxLevel-1) ? (&_channelInfos[_currentLevel+1]) : NULL;', "\n";
   print '    ChannelInfo * pci = (_currentLevel>0) ? (&_channelInfos[_currentLevel-1]) : NULL;', "\n";
   print '    if (_time==0)', "\n";
   print '        return UnknownLoadChange;', "\n";
   print '    // we were on this same channel and observed a different congestion ', "\n";
   print '    if (cci->lastTime==_time-1 && cci->lastCongested != congested)', "\n";
   print '        return congested ? MoreLoad : LessLoad;', "\n";
   print '    // we moved here from up where there was congestion, yet the congestion disappeared here', "\n";
   print '    else if (nci!=NULL && nci->lastTime==_time-1 && nci->lastCongested && !congested)', "\n";
   print '        return LessLoad;', "\n";
   print '    // we moved here from bottom where there was no congestion, yet the congestion appeared here', "\n";
   print '    else if (pci!=NULL && pci->lastTime==_time-1 && !pci->lastCongested && congested)', "\n";
   print '        return MoreLoad;', "\n";
   print '    return UnknownLoadChange;', "\n";
   print '}', "\n";
   print "\n";
   print 'ElasticAdaptation::LoadChange ElasticAdaptation::pingNoiseDetector(ElasticAdaptation::LoadChange direction)', "\n";
   print '{', "\n";
   print '    if (_noiseDetector > 0) {', "\n";
   print '        _noiseDetector--;', "\n";
   print '        SPLAPPTRC(L_INFO, "ElasticAdaptation: set off noise detector, " << _noiseDetector << " remaining.", SPL_OPER_DBG);', "\n";
   print '        return PotentialNoise;', "\n";
   print '    }', "\n";
   print '    else {', "\n";
   print '        return direction;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'ElasticAdaptation::LoadChange ElasticAdaptation::checkForChangeInLoadBasedOnThroughput(double throughput)', "\n";
   print '{', "\n";
   print '    if (_time==0)', "\n";
   print '        return UnknownLoadChange;', "\n";
   print '    ', "\n";
   print '    ChannelInfo * cci = &_channelInfos[_currentLevel];', "\n";
   print '    int nCurrent = mapChannelLevelToNumChannels(_currentLevel);', "\n";
   print '		', "\n";
   print '    int nUp = 0;', "\n";
   print '    ChannelInfo * nci = NULL;', "\n";
   print '    if (_currentLevel<_maxLevel-1) {', "\n";
   print '        nci = &_channelInfos[_currentLevel+1];', "\n";
   print '        nUp = mapChannelLevelToNumChannels(_currentLevel+1);', "\n";
   print '    }', "\n";
   print '		', "\n";
   print '    int nDown = 0;', "\n";
   print '    ChannelInfo * pci = NULL;', "\n";
   print '    if (_currentLevel>0) {', "\n";
   print '        pci = & _channelInfos[_currentLevel-1];', "\n";
   print '        nDown = mapChannelLevelToNumChannels(_currentLevel-1);', "\n";
   print '    }', "\n";
   print "\n";
   print '    double oldThroughput = 0.0;', "\n";
   print '    // we were were here the last time, but throughput changed', "\n";
   print '    if (cci->lastTime==_time-1) {', "\n";
   print '        oldThroughput = cci->firstThroughput;', "\n";
   print '        double throughputDiff = throughput - oldThroughput;', "\n";
   print '        if (throughputDiff < 0.0) {', "\n";
   print '            if (-throughputDiff > _changeSensitivity * throughput) {', "\n";
   print '                return pingNoiseDetector(LessLoad);', "\n";
   print '            }', "\n";
   print '        } else {', "\n";
   print '            if (throughputDiff > _changeSensitivity * oldThroughput) {', "\n";
   print '                return pingNoiseDetector(MoreLoad);', "\n";
   print '            }', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    // we moved here from up, yet the throughput increased', "\n";
   print '    else if (nci!=NULL && nci->lastTime==_time-1) {', "\n";
   print '        oldThroughput = nci->lastThroughput;', "\n";
   print '        if ((throughput - oldThroughput) > _changeSensitivity * oldThroughput) {', "\n";
   print '            return pingNoiseDetector(MoreLoad);', "\n";
   print '        }', "\n";
   print '    } ', "\n";
   print '    // we moved here from below, yet the throughput decreased', "\n";
   print '    else if (pci!=NULL && pci->lastTime==_time-1) {', "\n";
   print '        oldThroughput = pci->lastThroughput;', "\n";
   print '        if ((oldThroughput - throughput) > _changeSensitivity * throughput) {', "\n";
   print '            return pingNoiseDetector(LessLoad);', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    _noiseDetector = NOISE_LIMIT;', "\n";
   print '    return UnknownLoadChange;', "\n";
   print '}', "\n";
   print "\n";
   print 'void ElasticAdaptation::untrustOtherData(double throughput)', "\n";
   print '{', "\n";
   print '    for (int32_t i = 0; i < _maxLevel; ++i) {', "\n";
   print '        if (i != _currentLevel) {', "\n";
   print '            _channelInfos[i].trusted = false;', "\n";
   print '        }', "\n";
   print '        else {', "\n";
   print '            _channelInfos[i].firstThroughput = throughput;', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'bool ElasticAdaptation::trustBelow()', "\n";
   print '{', "\n";
   print '    if (_currentLevel == 0) {', "\n";
   print '        return false;', "\n";
   print '    }', "\n";
   print '    return _channelInfos[_currentLevel - 1].trusted;', "\n";
   print '}', "\n";
   print "\n";
   print 'bool ElasticAdaptation::trustAbove()', "\n";
   print '{', "\n";
   print '    if (_currentLevel == _maxLevel - 1) {', "\n";
   print '        return false;', "\n";
   print '    }', "\n";
   print '    return _channelInfos[_currentLevel + 1].trusted;', "\n";
   print '}', "\n";
   print "\n";
   print 'bool ElasticAdaptation::improvementTrendBelow(double throughput)', "\n";
   print '{', "\n";
   print '    if (_currentLevel == 0) {', "\n";
   print '        return false;', "\n";
   print '    }', "\n";
   print "\n";
   print '    ChannelInfo & pci = _channelInfos[_currentLevel-1];				', "\n";
   print '    if (!pci.trusted) {', "\n";
   print '        return false;', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    if ((throughput > pci.lastThroughput) && (throughput - pci.lastThroughput) > _changeSensitivity * pci.lastThroughput) {', "\n";
   print '        SPLAPPTRC(L_INFO, "ElasticAdaptation: improvement trend down: " << throughput << ", " << pci.lastThroughput, SPL_OPER_DBG);', "\n";
   print '        return true;', "\n";
   print '    }   ', "\n";
   print '    return false;', "\n";
   print '}', "\n";
   print "\n";
   print 'bool ElasticAdaptation::improvementTrendAbove(double throughput)', "\n";
   print '{', "\n";
   print '    if (_currentLevel == _maxLevel - 1) {', "\n";
   print '        return false;', "\n";
   print '    }', "\n";
   print "\n";
   print '    ChannelInfo & nci = _channelInfos[_currentLevel+1];				', "\n";
   print '    if (!nci.trusted) {', "\n";
   print '        return false;', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    if ((nci.lastThroughput > throughput) && (nci.lastThroughput - throughput) > _changeSensitivity * throughput) {', "\n";
   print '        SPLAPPTRC(L_INFO, "ElasticAdaptation: improvement trend down: " << throughput << ", " << nci.lastThroughput, SPL_OPER_DBG);', "\n";
   print '        return true;', "\n";
   print '    }   ', "\n";
   print '    return false;', "\n";
   print '}', "\n";
   print "\n";
   print 'int32_t ElasticAdaptation::getNumberOfChannels(bool congested, double throughput) ', "\n";
   print '{			', "\n";
   print '    switch (checkForChangeInLoadBasedOnCongestion(congested)) {				', "\n";
   print '        case PotentialNoise:', "\n";
   print '            return mapChannelLevelToNumChannels(_currentLevel);', "\n";
   print '        case LessLoad:', "\n";
   print '        case MoreLoad:', "\n";
   print '            SPLAPPTRC(L_INFO, "ElasticAdaptation: change in congestion, untrusting other data", SPL_OPER_DBG);', "\n";
   print '            untrustOtherData(throughput);', "\n";
   print '            break;', "\n";
   print '        default: ;', "\n";
   print '    }', "\n";
   print '		', "\n";
   print '    switch (checkForChangeInLoadBasedOnThroughput(throughput)) {', "\n";
   print '        case PotentialNoise:', "\n";
   print '            return mapChannelLevelToNumChannels(_currentLevel);', "\n";
   print '        case LessLoad:', "\n";
   print '        case MoreLoad:', "\n";
   print '            SPLAPPTRC(L_INFO, "ElasticAdaptation: change in throughput, untrusting other data", SPL_OPER_DBG);', "\n";
   print '            untrustOtherData(throughput);', "\n";
   print '            break;', "\n";
   print '        default: ;', "\n";
   print '    }', "\n";
   print '	', "\n";
   print '    // update info for the current channel', "\n";
   print '    ChannelInfo & cci = _channelInfos[_currentLevel];', "\n";
   print '    cci.lastTime = _time++;', "\n";
   print '    cci.lastThroughput = throughput;', "\n";
   print '    cci.lastCongested = congested;', "\n";
   print '    if (!cci.trusted) {', "\n";
   print '        cci.firstThroughput = throughput;', "\n";
   print '    }', "\n";
   print '    cci.trusted = true;', "\n";
   print "\n";
   print '    if (congested) {', "\n";
   print '        if ((improvementTrendBelow(throughput) && !trustAbove()) || ', "\n";
   print '             improvementTrendAbove(throughput) ||', "\n";
   print '            (_currentLevel == 0 && !trustAbove())) {', "\n";
   print '            if (_currentLevel < _maxLevel - 1) {', "\n";
   print '                SPLAPPTRC(L_INFO, "ElasticAdaptation: updward trend, exploring up", SPL_OPER_DBG);', "\n";
   print '                _currentLevel++;', "\n";
   print '            }', "\n";
   print '        }', "\n";
   print '        else if (!trustBelow()) {', "\n";
   print '            if (_currentLevel > 0) {', "\n";
   print '                SPLAPPTRC(L_INFO, "ElasticAdaptation: don\'t trust data below, exploring down", SPL_OPER_DBG);', "\n";
   print '                _currentLevel--;', "\n";
   print '            }', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    else {', "\n";
   print '        if (_currentLevel > 0) {', "\n";
   print '            SPLAPPTRC(L_INFO, "ElasticAdaptation: no congestion, level down", SPL_OPER_DBG);', "\n";
   print '            _currentLevel--; ', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    return mapChannelLevelToNumChannels(_currentLevel);', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '    : MY_BASE_OPERATOR(), ', "\n";
   print '      _done(false), _currentBuf(0), _bufferSize(';
   print $bufferSize;
   print '),', "\n";
   print '      _numOutputPorts(getNumberOfOutputPorts()),', "\n";
   print '      _numActivePorts(0),', "\n";
   print "\n";
   print '      _sleep(getNumberOfOutputPorts()),', "\n";
   print '      _stop(false), _measurePeriod(MEASURE_PERIOD), ', "\n";
   print '      _alarm(new AlarmThread<AdaptCallback>(_stop, _measurePeriod, AdaptCallback(*this))),', "\n";
   print "\n";
   print '      _prevTime(0.0), _prevTuples(0), _prevOutTuples(0),', "\n";
   print '      _adaptAlg(new ElasticAdaptation(RAPID_SCALING, THROUGHPUT_TOLERANCE, _numOutputPorts))', "\n";
   print '{', "\n";
   print '    if(!_bufferSize)', "\n";
   print '        _bufferSize = 1;', "\n";
   print '    for(uint32_t i=0; i<_numOutputPorts; ++i) {', "\n";
   print '        _buffers.push_back(new CircularQueue<ItemType>(_bufferSize));', "\n";
   print '        _sleepMutexes.push_back(new Mutex);', "\n";
   print '        _sleepCVs.push_back(new CV);', "\n";
   print '        _sleep[i] = false;', "\n";
   print '    }', "\n";
   print "\n";
   print '    if (INITIAL_THREADS_SPECIFIED) {', "\n";
   print '        _numActivePorts = INITIAL_THREADS;', "\n";
   print '    }', "\n";
   print '    else {', "\n";
   print '        if (ELASTIC) {', "\n";
   print '            _numActivePorts = 1;', "\n";
   print '        }', "\n";
   print '        else {', "\n";
   print '            _numActivePorts = _numOutputPorts;', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print "\n";
   print '    _adaptAlg->init(_numActivePorts);', "\n";
   print '    for (uint32_t i = _numActivePorts; i < _numOutputPorts; ++i) {', "\n";
   print '        _sleep[i] = true;', "\n";
   print '    }', "\n";
   print "\n";
   print '    SPLAPPTRC(L_INFO, "ElasticAdaptation: elasticity: " << (ELASTIC ? "on": "off"), SPL_OPER_DBG);', "\n";
   print '    SPLAPPTRC(L_INFO, "ElasticAdaptation: initial thread level: " << _numActivePorts, SPL_OPER_DBG);', "\n";
   print '    SPLAPPTRC(L_INFO, "ElasticAdaptation: congestion tolerance: " << CONGESTION_TOLERANCE, SPL_OPER_DBG);', "\n";
   print '    SPLAPPTRC(L_INFO, "ElasticAdaptation: measure period: " << MEASURE_PERIOD, SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    {', "\n";
   print '        // We need to protect the destruction of objects from the adapt thread, ', "\n";
   print '        // but make sure that we don\'t have the mutex when we join', "\n";
   print '        AutoMutex am(_adaptMutex);', "\n";
   print "\n";
   print '        for(uint32_t i=0; i<_numOutputPorts; ++i) {', "\n";
   print '            CircularQueue<ItemType> & buffer = *_buffers[i]; ', "\n";
   print '            for(size_t j=0, ju=buffer.getCapacity(); j<ju; ++j) {', "\n";
   print '                ItemType & item = buffer.getRawData(j);', "\n";
   print '                delete item.tuple;', "\n";
   print '            }', "\n";
   print '            delete &buffer;', "\n";
   print "\n";
   print '            delete _sleepMutexes[i];', "\n";
   print '            delete _sleepCVs[i];', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print "\n";
   print '    _stop = true;', "\n";
   print '    if (ELASTIC) {', "\n";
   print '        _alarm->join();', "\n";
   print '    }', "\n";
   print '    delete _alarm;', "\n";
   print '    delete _adaptAlg;', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::pause() {', "\n";
   print '#if AVOID_SCHED_YIELD', "\n";
   print '        for (uint32_t i=0; i< 30; i++) {', "\n";
   print '#    if defined(__powerpc__)', "\n";
   print '            __asm__ __volatile__("or 30,30,30");', "\n";
   print '#    elif !(defined (__i386__) ||  defined (__x86_64__))', "\n";
   print '            pthread_yield();', "\n";
   print '#    else', "\n";
   print '            __asm__ __volatile__("pause;");', "\n";
   print '#    endif', "\n";
   print '        }', "\n";
   print '#else', "\n";
   print '    pthread_yield();', "\n";
   print '#endif', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    if(punct == Punctuation::WindowMarker) ', "\n";
   print '    {', "\n";
   print '        ItemType item(NULL, punct);', "\n";
   print '        process(item);', "\n";
   print '    } else { // final punctuation', "\n";
   print '        // wake up sleeping threads', "\n";
   print '        for (uint32_t i = _numActivePorts; i < _numOutputPorts; ++i) {', "\n";
   print '            AutoMutex am(*_sleepMutexes[i]);', "\n";
   print '            _sleep[i] = false;', "\n";
   print '            _sleepCVs[i]->broadcast();', "\n";
   print '        }', "\n";
   print "\n";
   print '        // need to wait until all buffers flush', "\n";
   print '        ProcessingElement& pe = getPE();', "\n";
   print '        while(!pe.getShutdownRequested()) {', "\n";
   print '            uint32_t done = 0;', "\n";
   print '            for(size_t i=0; i<_numOutputPorts; ++i) ', "\n";
   print '                if(_buffers[i]->empty())', "\n";
   print '                    ++done;', "\n";
   print '            if(done==_numOutputPorts) ', "\n";
   print '                break;', "\n";
   print '            pause();', "\n";
   print '        }', "\n";
   print '        _done = true;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    ItemType item(const_cast<Tuple *>(&tuple), Punctuation::Invalid);', "\n";
   print '    process(item);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(ItemType const & item)', "\n";
   print '{', "\n";
   print '    AutoPortMutex apm(_bufferMutex, *this); // in case there are multiple threads calling us', "\n";
   print '    // this will reduce to an untaken branch in case there is only a single thread', "\n";
   print '    int cnt = 0;', "\n";
   print '    if(item.isTuple()) {', "\n";
   print '	    while(!getPE().getShutdownRequested()) {', "\n";
   print '	        CircularQueue<ItemType> & buffer = *_buffers[_currentBuf];', "\n";
   print '	        if(!buffer.full()) {', "\n";
   print '	            ItemType & citem = buffer.rear();', "\n";
   print '                if(citem.tuple)', "\n";
   print '                    citem.tuple->assign(*item.tuple);', "\n";
   print '                else', "\n";
   print '                    citem.tuple = item.tuple->clone();', "\n";
   print '                citem.punct = Punctuation::Invalid;', "\n";
   print '	            buffer.push_back();', "\n";
   print '	            _currentBuf = (_currentBuf+1) % _numActivePorts;', "\n";
   print '	            return;', "\n";
   print '	        } else {', "\n";
   print '	            _currentBuf = (_currentBuf+1) % _numActivePorts;', "\n";
   print '	        }', "\n";
   print '	        ++cnt;', "\n";
   print '	        if(cnt==_numActivePorts) {', "\n";
   print '	            pause();', "\n";
   print '	            cnt = 0;', "\n";
   print '	        }', "\n";
   print '	    }', "\n";
   print '    }', "\n";
   print '    else {', "\n";
   print '    	//for puncts, add the punct to each buffer', "\n";
   print '    	//if the buffer is full, then wait and try to add again till there', "\n";
   print '    	//is space available.', "\n";
   print '    	bool buffersToTry[_numOutputPorts];', "\n";
   print '    	bool stillBuffersRemaining = false;', "\n";
   print '    	for(uint32_t i=0; i<_numOutputPorts; ++i) {', "\n";
   print '    		if(getPE().getShutdownRequested()) return;', "\n";
   print '       	 	CircularQueue<ItemType> & buffer = *_buffers[i]; ', "\n";
   print '       	 	if(!buffer.full()) {', "\n";
   print '	            ItemType & citem = buffer.rear();', "\n";
   print '                citem.punct = item.punct;', "\n";
   print '	            buffer.push_back();', "\n";
   print '	            buffersToTry[i] = false;', "\n";
   print '	        } else {', "\n";
   print '	            buffersToTry[i] = true;', "\n";
   print '	            stillBuffersRemaining = true;', "\n";
   print '	        }', "\n";
   print '        }', "\n";
   print '    	while(stillBuffersRemaining) {', "\n";
   print '    		if(getPE().getShutdownRequested()) break;', "\n";
   print '    		pause();', "\n";
   print '    		stillBuffersRemaining = false;', "\n";
   print '    		for (uint32_t i = 0; i < _numOutputPorts; i++) {', "\n";
   print '    			if(buffersToTry[i]) {', "\n";
   print '    				CircularQueue<ItemType> & buffer = *_buffers[i];', "\n";
   print '					if(!buffer.full()) {', "\n";
   print '						ItemType & citem = buffer.rear();', "\n";
   print '						citem.punct = item.punct;', "\n";
   print '						buffer.push_back();', "\n";
   print "\n";
   print '						buffersToTry[i] = false;', "\n";
   print '					}', "\n";
   print '					else {', "\n";
   print '						stillBuffersRemaining = true;', "\n";
   print '					}', "\n";
   print '    			}', "\n";
   print '    		}', "\n";
   print '    	}', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t index) ', "\n";
   print '{', "\n";
   print '    CircularQueue<ItemType> & buffer = *_buffers[index];', "\n";
   print '    while(!getPE().getShutdownRequested()) {', "\n";
   print "\n";
   print '        // only go to sleep AFTER buffer is flushed', "\n";
   print '        if (_sleep[index] && buffer.empty()) {', "\n";
   print '            AutoMutex am(*_sleepMutexes[index]);', "\n";
   print '            while (_sleep[index]) {', "\n";
   print '                _sleepCVs[index]->wait(*_sleepMutexes[index]);', "\n";
   print '            }', "\n";
   print '        }', "\n";
   print "\n";
   print '        BackoffSpinner spinner;', "\n";
   print '        while(buffer.empty()) {', "\n";
   print '            if(getPE().getShutdownRequested() || _done)', "\n";
   print '                return;', "\n";
   print '            spinner.wait();', "\n";
   print '        }', "\n";
   print '        ItemType & item = buffer.front();', "\n";
   print '        if(item.isTuple()) {', "\n";
   print '            submit(*item.tuple, index);', "\n";
   print '            item.tuple->clear();', "\n";
   print '        }', "\n";
   print '        else ', "\n";
   print '            submit(item.punct, index);', "\n";
   print '        buffer.pop_front();', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady()', "\n";
   print '{', "\n";
   print '    createThreads(_numOutputPorts);', "\n";
   print '    if (ELASTIC) {', "\n";
   print '        _alarm->create();', "\n";
   print '    }', "\n";
   print '    _prevTime = SPL::Functions::Time::getTimestampInSecs();', "\n";
   print '}', "\n";
   print "\n";
   print 'double MY_OPERATOR_SCOPE::MY_OPERATOR::getThroughput()', "\n";
   print '{', "\n";
   print '    double currTime = SPL::Functions::Time::getTimestampInSecs();', "\n";
   print '    double timeDiff = currTime - _prevTime;', "\n";
   print '    _prevTime = currTime;', "\n";
   print "\n";
   print '    // Two pitfalls we have to avoid:', "\n";
   print '    //', "\n";
   print '    // 1) If we only look at the current number of active ports (_numActivePorts), then we ', "\n";
   print '    // may undercount the number of tuples processed, which would cause our difference to ', "\n";
   print '    // be wrong.', "\n";
   print '    //', "\n";
   print '    // 2) If we instead count the tuples processed by the input port, we will overcount. Yes,', "\n";
   print '    // in a steady-state situation, tuples processed and submitted will be rougly equal. But, ', "\n";
   print '    // note that the amount we overcount by will increase as we increase the number of ', "\n";
   print '    // threads. This is bad, as it gives an artificial "reward" to the elastic algorithm for ', "\n";
   print '    // increasing the number of threads, and the reward is proportionally higher when absolute ', "\n";
   print '    // throughput is low - which is precisely when we will have a large number of threads.', "\n";
   print '    uint64_t currNTuples = 0;', "\n";
   print '    for (uint32_t i = 0; i < _numOutputPorts; ++i) {', "\n";
   print '        currNTuples += getContext().getMetrics().getOutputPortMetric(i, OperatorMetrics::nTuplesSubmitted).getValue();', "\n";
   print '    }', "\n";
   print "\n";
   print '    double nTuplesDiff = currNTuples - _prevTuples;', "\n";
   print '    _prevTuples = currNTuples;', "\n";
   print "\n";
   print '    return nTuplesDiff / timeDiff;', "\n";
   print '}', "\n";
   print "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::isCongested()', "\n";
   print '{', "\n";
   print '    double sum = 0.0;', "\n";
   print '    for (uint32_t i = 0; i < _numActivePorts; ++i) {', "\n";
   print '        size_t size = _buffers[i]->getSize();', "\n";
   print '        size_t capacity = _buffers[i]->getCapacity();', "\n";
   print '        sum += (double)size / capacity;', "\n";
   print '    }', "\n";
   print "\n";
   print '    return (sum / _numActivePorts) > CONGESTION_TOLERANCE;', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::adapt()', "\n";
   print '{', "\n";
   print '    AutoMutex am(_adaptMutex); // make sure these objects aren\'t destroyed while we\'re using them', "\n";
   print "\n";
   print '    if (!_done) {', "\n";
   print '        double throughput = getThroughput();', "\n";
   print '        bool congested = isCongested();', "\n";
   print '        uint32_t oldPorts = _numActivePorts;', "\n";
   print '        uint32_t newPorts = _adaptAlg->getNumberOfChannels(congested, throughput);', "\n";
   print '        if (newPorts != oldPorts && newPorts <= _numOutputPorts) {', "\n";
   print '            {', "\n";
   print '                // we grab the lock because if these values changed in the middle of the ingestion', "\n";
   print '                // thread going over the queues, Very Bad Things could happen', "\n";
   print '                AutoPortMutex apm(_bufferMutex, *this);', "\n";
   print '                _numActivePorts = newPorts;', "\n";
   print '                if (_currentBuf >= _numActivePorts) {', "\n";
   print '                    _currentBuf = _currentBuf % _numActivePorts;', "\n";
   print '                }', "\n";
   print '            }', "\n";
   print "\n";
   print '            if (oldPorts > newPorts) {', "\n";
   print '                // thread level down, put threads to sleep', "\n";
   print '                for (uint32_t i = newPorts; i < oldPorts; ++i) {', "\n";
   print '                    _sleep[i] = true;', "\n";
   print '                }', "\n";
   print '            }', "\n";
   print '            else {', "\n";
   print '                // thread level up, wake threads up', "\n";
   print '                for (uint32_t i = oldPorts; i < newPorts; ++i) {', "\n";
   print '                    AutoMutex am(*_sleepMutexes[i]);', "\n";
   print '                    _sleep[i] = false;', "\n";
   print '                    _sleepCVs[i]->broadcast();', "\n";
   print '                }', "\n";
   print '            }', "\n";
   print '        }', "\n";
   print "\n";
   print '        SPLAPPTRC(L_INFO, "ElasticAdaptation: throughput: " << throughput << ', "\n";
   print '                          ", congestion: " << congested << ', "\n";
   print '                          ", suggestion: " << newPorts << ', "\n";
   print '                          ", active: " << _numActivePorts, SPL_OPER_DBG);', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
