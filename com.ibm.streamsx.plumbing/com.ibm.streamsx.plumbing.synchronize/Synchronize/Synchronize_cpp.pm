
package Synchronize_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/*', "\n";
   print ' * Copyright (C) 2013, 2016 International Business Machines Corporation. ', "\n";
   print ' * All Rights Reserved.', "\n";
   print ' */', "\n";
   print "\n";
   print "\n";
   print '#include <sys/time.h>', "\n";
   print '#include <time.h>', "\n";
   print '#include <float.h>', "\n";
   print '#include <SPL/Runtime/Utility/BackoffSpinner.h>', "\n";
   print "\n";
   print "\n";
     use strict;
     use warnings;
   
     # get the name of this operator's template
     my $myOperatorKind = $model->getContext()->getKind();
   
     # this operator must have the same number of input and output ports
     SPL::CodeGen::exit("Sorry, input and output port counts are not the same") 
       unless $model->getNumberOfInputPorts() == $model->getNumberOfOutputPorts();
   
     # the types of the input and output ports must be the same, port by port
     for (my $i=0; $i < $model->getNumberOfInputPorts(); $i++) {
       print "// DEBUG: inputPort[$i] type is " . $model->getInputPortAt($i)->getSPLTupleType() . "\n";
       print "// DEBUG: outputPort[$i] type is " . $model->getOutputPortAt($i)->getSPLTupleType() . "\n";
       SPL::CodeGen::exit("Sorry, input and output ports do not have matching types") 
         unless $model->getInputPortAt($i)->getSPLTupleType() eq $model->getOutputPortAt($i)->getSPLTupleType();
     }
     
     # the 'timeAttribute' parameter must have the same number of values as the number of input ports
     SPL::CodeGen::exit("Sorry, not enough 'timeAttribute' values for all of the input ports") 
       if $model->getParameterByName("timeAttributes")->getNumberOfValues() < $model->getNumberOfInputPorts();
     SPL::CodeGen::exit("Sorry, not enough input ports for all of the 'timeAttribute' values") 
       if $model->getParameterByName("timeAttributes")->getNumberOfValues() > $model->getNumberOfInputPorts();
   
     # get C++ expressions for getting the values of the required 'timeAttributes' parameter
     my @timeAttributes = ();
     for (my $i=0; $i < $model->getParameterByName("timeAttributes")->getNumberOfValues(); $i++) {
       push @timeAttributes, $model->getParameterByName("timeAttributes")->getValueAt($i)->getCppExpression();
     }
   
     # get C++ expression for getting the value of the optional 'timeFactor' parameter
     my $timeFactor = $model->getParameterByName("timeFactor") ? $model->getParameterByName("timeFactor")->getValueAt(0)->getCppExpression() : 0;
     my $ignorePunctuation = $model->getParameterByName("ignorePunctuation") ? $model->getParameterByName("ignorePunctuation")->getValueAt(0)->getCppExpression() : 0;
     print "// DEBUG: timeFactor is '$timeFactor'\n";
     print "// DEBUG: ignorePunctuation is '$ignorePunctuation'\n";
   print "\n";
   print "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{', "\n";
   print '    SPLLOG(L_TRACE, "entering ';
   print $myOperatorKind;
   print ' constructor", "Synchronize");', "\n";
   print "\n";
   print '    // initialize parameter-based constants', "\n";
   print "\n";
   print '    timeFactor = ';
   print $timeFactor;
   print ';', "\n";
   print '    ignorePunctuation = ';
   print $ignorePunctuation;
   print ';', "\n";
   print '    if (timeFactor<0) THROW (SPLRuntimeOperator, "Sorry, \'timeFactor\' parameter must be greater than zero");', "\n";
   print "\n";
   print '    // initialize state variables', "\n";
   print "\n";
   print '    previousSubmitTime = 0;', "\n";
   print '    previousTupleTimestamp = 0;', "\n";
   print "\n";
   print '    for (int i=0; i < ';
   print $model->getNumberOfInputPorts();
   print '; i++) {', "\n";
   print '    	nextTimestamp[i] = 0;', "\n";
   print '	stopCount[i] = 0;', "\n";
   print '	clearCount[i] = 0;', "\n";
   print '    }', "\n";
   print "\n";
   print '   SPLLOG(L_TRACE, "leaving ';
   print $myOperatorKind;
   print ' constructor", "Synchronize");', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '	cvStopped.broadcast();', "\n";
   print '	cvCleared.broadcast();', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// get the current time, as a \'double\', in seconds since the Unix epoch, with microsecond accuracy', "\n";
   print 'double theTimeRightNow()', "\n";
   print '{', "\n";
   print '  struct timeval tv;', "\n";
   print '  gettimeofday(&tv, NULL);', "\n";
   print '  return (double)tv.tv_sec + (double)tv.tv_usec / 1000000.0;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// determine whether or not this port is next in line to submit its tuple', "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::itsOurTurn(uint32_t ourPort)', "\n";
   print '{', "\n";
   print '    uint32_t nextPort = -1;', "\n";
   print '    double oldestTimestamp = DBL_MAX;', "\n";
   print '    for (int i=0; i < ';
   print $model->getNumberOfInputPorts();
   print '; i++) {', "\n";
   print '      if ( stopCount[i] != stopCount[ourPort] ) continue;', "\n";
   print '      if ( nextTimestamp[i] == 0 ) return false;', "\n";
   print '      if ( nextTimestamp[i] >= oldestTimestamp ) continue;', "\n";
   print '      nextPort = i;', "\n";
   print '      oldestTimestamp = nextTimestamp[i];', "\n";
   print '    }', "\n";
   print '    if (nextPort == -1) SPLLOG(L_ERROR, "all input ports stopped", "Synchronize");', "\n";
   print "\n";
   print '    return (ourPort==nextPort);', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLLOG(L_TRACE, "entering ';
   print $myOperatorKind;
   print ' process(," << port << "), tuple=" << tuple, "Synchronize");', "\n";
   print "\n";
   print '    // get the value of the timestamp attribute from the tuple received by this input port', "\n";
   print '    switch(port) {', "\n";
   for (my $i=0; $i < $model->getParameterByName("timeAttributes")->getNumberOfValues(); $i++) {
         print "    case $i: { const IPort${i}Type& iport\$${i} = tuple; nextTimestamp[$i] = static_cast<double>($timeAttributes[$i]); } break;\n";
   }
   print ' ', "\n";
   print '    }', "\n";
   print '    SPLLOG(L_TRACE, "next timestamp for port " << port << " is " << nextTimestamp[port], "Synchronize");', "\n";
   print "\n";
   print '    // wait (in a spin loop) until this port\'s tuple is next in time sequence', "\n";
   print '    BackoffSpinner spinner;', "\n";
   print '    SPLLOG(L_TRACE, "port " << port << " waiting for its turn", "Synchronize");', "\n";
   print '    while( !getPE().getShutdownRequested() && !itsOurTurn(port) ) spinner.wait();', "\n";
   print "\n";
   print '    // wait a bit longer until its time to replay this port\'s tuple if \'timeFactor\' is set', "\n";
   print '    if (timeFactor>0) {', "\n";
   print '       const double delay = previousTupleTimestamp ? ( nextTimestamp[port] - previousTupleTimestamp ) / timeFactor : 0;', "\n";
   print '       const double theTimeToSubmit = previousSubmitTime + delay; // note that \'previousSubmitTime\' will be zero on first tuple', "\n";
   print '       SPLLOG(L_TRACE, "port " << port << " taking its turn, waiting " << delay << " seconds", "Synchronize");', "\n";
   print '       while ( !getPE().getShutdownRequested() && theTimeRightNow() < theTimeToSubmit ) spinner.wait();', "\n";
   print '    }', "\n";
   print "\n";
   print '    // advance the shared timestamp', "\n";
   print '    if (previousTupleTimestamp < nextTimestamp[port]) previousTupleTimestamp = nextTimestamp[port];', "\n";
   print "\n";
   print '    // forward the tuple downstream, and remember when we sent it', "\n";
   print '    SPLLOG(L_TRACE, "port " << port << " submitting tuple=" << tuple, "Synchronize");', "\n";
   print '    previousSubmitTime = theTimeRightNow();', "\n";
   print "\n";
   print '    // submit the current tuple now', "\n";
   print '    submit(tuple, port);', "\n";
   print "\n";
   print '    // this port needs to receive another tuple before any port can proceed', "\n";
   print '    nextTimestamp[port] = 0;', "\n";
   print "\n";
   print '    SPLLOG(L_TRACE, "leaving ';
   print $myOperatorKind;
   print ' process(," << port << "), tuple=" << tuple, "Synchronize");', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'std::string printCounts(uint32_t* counters) {', "\n";
   print "\n";
   print '   std::stringstream buffer;', "\n";
   print '   buffer << "[";', "\n";
   print '   for (int i=0; i < ';
   print $model->getNumberOfInputPorts();
   print '; i++) { buffer << (i==0 ? "" : ",") << counters[i]; }', "\n";
   print '   buffer << "]";', "\n";
   print '   return buffer.str();', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// determine whether or not all ports have caught up to this port at a checkpoint', "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::allCaughtUp(uint32_t* counters, uint32_t port)', "\n";
   print '{', "\n";
   print '    for (int i=0; i < ';
   print $model->getNumberOfInputPorts();
   print '; i++) { if (  counters[i]<counters[port] ) return false; }', "\n";
   print '    return true;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLLOG(L_TRACE, "entering ';
   print $myOperatorKind;
   print ' process(" << punct << ", " << port << ")", "Synchronize");', "\n";
   print '    ', "\n";
   print '    if (ignorePunctuation && punct!=Punctuation::FinalMarker) return;', "\n";
   print "\n";
   print '    {', "\n";
   print '	AutoMutex am(mutexStopped);', "\n";
   print '	stopCount[port]++;', "\n";
   print '	SPLLOG(L_DEBUG, "port " << port << " stopped at " << punct << " " << stopCount[port] << ", others at p=" << printCounts(stopCount), "Synchronize");', "\n";
   print '	while ( !getPE().getShutdownRequested() && !allCaughtUp(stopCount, port) ) cvStopped.wait(mutexStopped);', "\n";
   print '	cvStopped.broadcast();', "\n";
   print '    }', "\n";
   print "\n";
   print '    submit(punct, port);', "\n";
   print '    previousSubmitTime = 0; ', "\n";
   print '    previousTupleTimestamp = 0;', "\n";
   print '    nextTimestamp[port] = 0;', "\n";
   print "\n";
   print '    {', "\n";
   print '	AutoMutex am(mutexCleared);', "\n";
   print '	clearCount[port]++;', "\n";
   print '	SPLLOG(L_TRACE, "port " << port << " cleared at " << punct << " " << clearCount[port] << ", others at c=" << printCounts(clearCount), "Synchronize");', "\n";
   print '	while ( !getPE().getShutdownRequested() && !allCaughtUp(clearCount, port) ) cvCleared.wait(mutexCleared);', "\n";
   print '	cvCleared.broadcast();', "\n";
   print '    }', "\n";
   print "\n";
   print '    SPLLOG(L_DEBUG, "port " << port << " resuming after " << punct << " " << stopCount[port] << ", others at p=" << printCounts(stopCount) << ", c=" << printCounts(clearCount), "Synchronize");', "\n";
   print '    SPLLOG(L_TRACE, "leaving ';
   print $myOperatorKind;
   print ' process(" << punct << ", " << port << ")", "Synchronize");', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
