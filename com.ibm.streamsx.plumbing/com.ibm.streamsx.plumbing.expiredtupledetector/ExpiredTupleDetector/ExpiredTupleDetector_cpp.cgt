/*
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2017
*/

/*
Code contributions were made by three of the Streams team members.

Possible use cases where this operator can be used:

1) Aging out tuples based on application specific criteria.
2) Response timeout detection and replaying data tuples to an external service.
3) Event notification to external consuming applications at a later time in the future.
4) Design patterns requiring storing and forwarding of tuples after a preset delay.
*/

<%
	my $key = $model->getParameterByName("key");
	$key = $key->getValueAt(0)->getSPLExpression();
	# The $key may have the InputStreamName.attribute (e-g: FlightIn.flightId)
	# We will need only the attribute name without the input stream name.
	my @fields = split /\./, $key;
	$key = $fields[1];
    my $expireTime = $model->getParameterByName("expireTime");
    $expireTime = $expireTime->getValueAt(0)->getCppExpression();
    my $allowExpireTimeOverride = $model->getParameterByName("allowExpireTimeOverride");
    $allowExpireTimeOverride = $allowExpireTimeOverride->getValueAt(0)->getCppExpression();
    my $numberOfOutputPorts = $model->getNumberOfOutputPorts();
    my $snapshotAttributeName = "";
    
	# If the optional output stream 1 is present, get the name of its only attribute.
    if ($numberOfOutputPorts > 1) {
    	my $secondOutputPort = $model->getOutputPortAt(1);
    	my $numberOfAttributes = $secondOutputPort->getNumberOfAttributes();
    	
    	if ($numberOfAttributes > 1) {
    		SPL::CodeGen::exitln("Optional second output stream must have only one attribute.\n" .
    			"That single attribute must be of type list<YOUR_EVENT_TUPLE_TYPE>.");
    	}
    	
    	$snapshotAttributeName = $secondOutputPort->getAttributeAt(0)->getName();
    }
    
	# Get the first attribute name in the third input stream.
	# That attribute will carry the new expire time that user will send.
    my $thirdInputPort = $model->getInputPortAt(2);
    my $attributeCnt = $thirdInputPort->getNumberOfAttributes();
    
    if ($attributeCnt > 1) {
		SPL::CodeGen::exitln("Third input stream must have only one attribute.\n" .
			"That single attribute must be of type uint64.");
    }
    
    my $expireTimeAttributeName = "";
    $expireTimeAttributeName = $thirdInputPort->getAttributeAt(0)->getName();
    
    # Get the first attribute name in the fourth input stream.
    # That attribute will carry the identifier of the tuple that the 
    # user wants to erase from the time ordered list maintained within
    # this operator.
    my $fourthInputPort = $model->getInputPortAt(3);
    $attributeCnt = $fourthInputPort->getNumberOfAttributes();

    if ($attributeCnt > 1) {
	   SPL::CodeGen::exitln("Fourth input stream must have only one attribute.\n" .
	      "That single attribute must be of the same type as the attribute specified in this operator's key parameter.");
    }

    my $deleteTupleAttributeName = "";
    $deleteTupleAttributeName = $fourthInputPort->getAttributeAt(0)->getName();
%>

<%SPL::CodeGen::implementationPrologue($model);%>

// Constructor
MY_OPERATOR::MY_OPERATOR()
  : _inflightTupleMap(<%=$expireTime%>), _firstUnexpiredTimestamp(0), 
	_expirationTimeLimit(<%=$expireTime%>), _allowExpireTimeOverride(<%=$allowExpireTimeOverride%>)
{
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
}

void MY_OPERATOR::process(const Tuple & tuple, uint32_t port)
{
    if (port == 0) { 
        // This data tuple is sent by the upstream operator.
        const IPort0Type & ituple = static_cast<const IPort0Type&>(tuple);
    	if (_expirationTimeLimit == 0) {
        	// If the current expire time is set to 0, then there is no need to insert this
        	// tuple into our in-flight tuple map. Let us send out this tuple right away.
    		IPort0Type & otuple = const_cast<IPort0Type&>(ituple);
    		submit(otuple, 0);
    	} else {
            // We will simply insert it into the in-flight tuple map that is periodically
            // scanned for detecting any time-out/expiry conditions of this tuple.
            // Lock at the minimum scope
            SPL::AutoMutex autoMutex(_mutex);
            // Before adding this tuple to the map, ensure it is not already there with the same key.
            // If it is already present, remove it before adding the new one.
            _inflightTupleMap.eraseIfExists(ituple.get_<%=$key%>());
            _inflightTupleMap.put(ituple.get_<%=$key%>(), ituple, 0);
        }
    }
    else if (port == 1) {
        // Periodic timer tuple that will make us check for any tuples
        // that just got expired with their time to live within our inflight tuple map.
        if (_allowExpireTimeOverride == true) {
            // Lock at the minimum scope
            SPL::AutoMutex autoMutex(_mutex);
			// Detect expired tuples. If there are any, they will be moved 
			// to a separate expired list data structure which is internal to
			// the AgedMap implementation. That data structure can be iterated in
			// the code segment outside of this if block.
            //
            // If this operator is configured to allow the override of expireTime value,
            // then we will have to go through the entire time ordered list. It will not
            // be a faster execution. We will caution the user about this in the 
            // operator documentation not to use this feature if they plan to have more than
            // 100K entries in our time ordered list.
            // We will call an overloaded expire method that takes an argument to decide
            // whether to check all the list elements for expiration or not.
            // Method argument true here means check all the list elements.
            _inflightTupleMap.expire(true);
        } else {   	    	
			// We will only try to grab the lock and check the map if there are any expired tuples.
			// Get current time.
			uint64_t currentTime = _inflightTupleMap.getCurrentTime();
			if ((currentTime - _firstUnexpiredTimestamp) >= _expirationTimeLimit) {
				// Lock at the minimum scope
				SPL::AutoMutex autoMutex(_mutex);
				// Detect expired tuples. If there are any, they will be moved 
				// to a separate expired list data structure which is internal to
				// the AgedMap implementation. That data structure can be iterated in
				// the code segment outside of this if block.
				// This operator is configured not to allow the override of expireTime value.
				// In that case, we need not iterate through the entire time ordered list. So, we will
				// call a different overloaded expire method that is more efficient.
				_inflightTupleMap.expire(_firstUnexpiredTimestamp);
			}
        }

		// Now iterate through expired entries without holding the mutex lock. Since there is only
		// one thread doing this iteration, this is thread-safe.
		// Ignore the third argument below (replyCount). That is something carried over from
		// the legacy code of the customer project where this logic was originally implemented.
		SPL::rstring key = "";
		IPort0Type otuple;
		SPL::uint16 replayCount = 0;
		while (_inflightTupleMap.getExpiredEntry(key, otuple, replayCount)) {
			submit(otuple, 0);
		}
    } else if (port == 2) {
    	// This tuple is sent by an upstream operator, whenever the expire time 
    	// needs to be overridden/changed to a new value. Permit this only if the user
    	// configured this operator to allow such an operation.
    	if (_allowExpireTimeOverride == false) {
            SPLAPPTRC(L_DEBUG, 
            	"User is attempting to override the expireTime value when that operation is not permitted.", "ExpiredTupleDetector");    		
    	} else {
    		const IPort2Type & ituple = static_cast<const IPort2Type&>(tuple);
			uint64_t newExpireTime = ituple.get_<%=$expireTimeAttributeName%>();
			// Log this event in the PE log.
			SPLAPPTRC(L_DEBUG, "User is overriding the expireTime value. Before override=" <<
				_expirationTimeLimit << ", After override=" << newExpireTime, "ExpiredTupleDetector");
    		// Lock at the minimum scope
			SPL::AutoMutex autoMutex(_mutex);
			// Change the expire time.
			_expirationTimeLimit = newExpireTime;
			// Set this new expire time value in the AgedMap layer.
			_inflightTupleMap.setExpireTime(newExpireTime);
    	}
    } else if (port == 3) {
    	// In this input port, we will receive a tuple that contains the
    	// identifier of the data tuple that the user wants to delete from
    	// this operator's time ordered list.
        const IPort3Type & ituple = static_cast<const IPort3Type&>(tuple);
    	// Lock at the minimum scope.
    	SPL::AutoMutex autoMutex(_mutex);
        // Delete the data tuple if it is present in our time ordered list.
        bool result = _inflightTupleMap.eraseIfExists(ituple.get_<%=$deleteTupleAttributeName%>());
        
        if (result == true) {
        	SPLAPPTRC(L_ERROR, "User action to delete a data tuple waiting for future expiration." << 
        		" <%=$deleteTupleAttributeName%>=" << ituple.get_<%=$deleteTupleAttributeName%>() <<
				". Result=Successfully deleted.", "ExpiredTupleDetector");
        } else {
        	SPLAPPTRC(L_ERROR, "User action to delete a data tuple waiting for future expiration." << 
        		" <%=$deleteTupleAttributeName%>=" << ituple.get_<%=$deleteTupleAttributeName%>() <<
				". Result=Tuple not found.", "ExpiredTupleDetector");        	
        }
    } else if (port == 4) {
    	// This is an optional port.
    	// When a tuple arrives in this port, that means a snapshot of the agedMap needs to be sent out.    	
    	<%if ($numberOfOutputPorts > 1) {%>
    	// Lock at the minimum scope.
    	SPL::AutoMutex autoMutex(_mutex);
		// It is assumed that the second output stream has this single attribute:
		// list<YOUR_EVENT_TUPLE_TYPE> ttlSnapshotList
		// e-g: TTLSnapshotType = list<FlightType> ttlSnapshotList;
    	OPort1Type otuple;
		SPL::list<IPort0Type> & timeOrderedListOfItems = otuple.get_<%=$snapshotAttributeName%>();
    	if (_inflightTupleMap.getTimeOrderedListOfItems(timeOrderedListOfItems) == true) {
    		submit(otuple, 1);
    	}
		<%}%>
    }
}

<%SPL::CodeGen::implementationEpilogue($model);%>
