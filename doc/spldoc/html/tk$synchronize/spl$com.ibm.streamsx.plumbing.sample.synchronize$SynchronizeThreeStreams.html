<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="SPL File SynchronizeThreeStreams.spl"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_compilationunit"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>SPL File SynchronizeThreeStreams.spl</title>
</head>
<body id="spldoc_compilationunit">


<h1 class="title topictitle1">SPL File <tt class="ph tt">SynchronizeThreeStreams.spl</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">streamsx.plumbing</a> &gt; <a class="xref" href="tk$synchronize.html">synchronize 1.0.0</a> &gt; <a class="xref" href="ns$com.ibm.streamsx.plumbing.sample.synchronize.html">com.ibm.streamsx.plumbing.sample.synchronize</a> &gt; SynchronizeThreeStreams.spl</p>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Content</h2>
  
  <dl class="dl">
    <dt class="dt dlterm"/>
<dd class="dd"/>

    
      <dt class="dt dlterm splhead-2">Operators</dt>

      <dd class="dd">
<ul class="sl simple">
<li class="sli"><strong class="ph b"><a class="xref" href="spl$com.ibm.streamsx.plumbing.sample.synchronize$SynchronizeThreeStreams.html#spldoc_compilationunit__composite_operator__SynchronizeThreeStreams">SynchronizeThreeStreams</a></strong>: This sample application for the Synchronize operator reads three pre-recorded streams from three files.
</li>

</ul>

      </dd>

    
    
      <dt class="dt dlterm splhead-2">Functions</dt>

      <dd class="dd">
<ul class="sl simple">
<li class="sli"><strong class="ph b"><a class="xref" href="spl$com.ibm.streamsx.plumbing.sample.synchronize$SynchronizeThreeStreams.html#spldoc_compilationunit__function__SecondsToTimestamp.float64">SecondsToTimestamp(float64)</a></strong>
</li>

</ul>

      </dd>

    
  </dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Composites</h2>
  
</div>

<div class="section" id="spldoc_compilationunit__composite_operator__SynchronizeThreeStreams"><h2 class="title sectiontitle splpart">public composite SynchronizeThreeStreams</h2>
  
</div>

<div class="section">

<p class="p">This sample application for the Synchronize operator reads three pre-recorded streams from three files. Two files contain phrases of text from the audio tracks of several short videos, as transcribed by two speech recognition engines. The third file contains phrases of text from the subtitle track of one of the videos. Each tuple created from each line of each file includes the starting time of each phrase, relative to the beginning of its video, and duration of the phrase in the video. Punctuation is manually inserted into the streams at the end of each video's phrases.
</p>

<p class="p">The Synchronize operator uses the starting times to synchronize the three streams, which are merged into a single transcript, with each stream's phrases in a separate column, annotated with their starting times and durations.
</p>

</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section"><h2 class="title sectiontitle splhead-2">Composite Operator Graph</h2>
  
</div>

<div class="section splgraph">
  <embed class="image" src="../../image/tk$synchronize/op$com.ibm.streamsx.plumbing.sample.synchronize$SynchronizeThreeStreams.svg" width="552" height="198"/>
</div>

<div class="section"><h2 class="title sectiontitle splhead-2">SPL Source Code</h2>
  
</div>


<div class="section">
   <pre class="pre codeblock">

 composite SynchronizeThreeStreams {
 
 	type PhraseType =  
 		rstring outputDirectory, 
 		rstring outputFilename, 
 		rstring indention,
 		rstring phrase, 
 		float64 start, 
 		float64 duration ;
 	
 	graph 
 
     // read stream of phrases from first speech recognition engine and insert punctuation between videos
 	
 	stream&lt;PhraseType&gt; Speech1Stream = FileSource() { param file: "sync4.Speech1PhraseStream.in"; format: csv; }
 	
 	stream&lt;PhraseType&gt; PunctuatedSpeech1Stream = Punctor(Speech1Stream) {
 	param punctuate: outputDirectory=="WindowMarker"; position: after; }
 	
 	stream&lt;PhraseType&gt; IndentedPunctuatedSpeech1Stream as Out1 = Functor(PunctuatedSpeech1Stream as Out) {
 	param filter: outputDirectory!="WindowMarker"; 
 	output Out1: indention = ""; }
 
 
     // read stream of phrases from second speech recognition engine, add indention, and insert punctuation between videos
 	
 	stream&lt;PhraseType&gt; Speech2Stream = FileSource() { param file: "sync4.Speech2PhraseStream.in"; format: csv; }
 	
 	stream&lt;PhraseType&gt; PunctuatedSpeech2Stream = Punctor(Speech2Stream) {
 	param punctuate: outputDirectory=="WindowMarker"; position: after; }
 	
 	stream&lt;PhraseType&gt; IndentedPunctuatedSpeech2Stream as Out2 = Functor(PunctuatedSpeech2Stream) {
 	param filter: outputDirectory!="WindowMarker"; 
 	output Out2: indention = "\t\t\t\t"; }
 	
 
     // read stream of phrases from subtitle track of one video, add more indention, and insert punctuation between videos
 
 	stream&lt;PhraseType&gt; SubtitleStream = FileSource() { param file: "sync4.SubtitleStream.in"; format: csv; }
 	
 	stream&lt;PhraseType&gt; PunctuatedSubtitleStream = Punctor(SubtitleStream) {
 	param punctuate: outputDirectory=="WindowMarker"; position: after; }
 	
 	stream&lt;PhraseType&gt; IndentedPunctuatedSubtitleStream as OutT = Functor(PunctuatedSubtitleStream) {
 	param filter: outputDirectory!="WindowMarker"; 
 	output OutT: indention = "\t\t\t\t\t\t\t\t"; }
 	
     // synchronize all three streams
 	
 	( stream&lt;PhraseType&gt; SynchronizedSpeech1Stream ;
 	  stream&lt;PhraseType&gt; SynchronizedSpeech2Stream ;
 	  stream&lt;PhraseType&gt; SynchronizedSubtitleStream ) = com.ibm.streamsx.plumbing.synchronize::Synchronize( 
                                                             IndentedPunctuatedSpeech1Stream as In1; 
                                                             IndentedPunctuatedSpeech2Stream as In2; 
                                                             IndentedPunctuatedSubtitleStream as InT) {
 	param 
 		timeAttributes: In1.start, In2.start, InT.start; 
 		timeFactor: 0.0; // replay as fast as possible
 	config threadedPort: 
 		queue(In1, Sys.DropFirst, 1000),
 		queue(In2, Sys.DropFirst, 1000),
 		queue(InT, Sys.DropFirst, 1000); }	
 
     // merge synchronized streams into a single transcript
 
 	() as Transcript = Custom(SynchronizedSpeech1Stream, SynchronizedSpeech2Stream, SynchronizedSubtitleStream as In) {
 	logic state: {
 		rstring filename = dataDirectory() + "/SynchronizeThreeStreams.transcript.out";
 		mutable uint64 file = 0; }
 	onTuple In: {	
 		mutable int32 error = 0;	
 		if (file==0ul) { 
  			file = fopen(filename , "w", error); 
 			assert(error==0, "sorry, could not open '" + filename + "', " + strerror(error)); }
 		if (length(phrase)&gt;0) {
 			rstring timeline = indention + "at " + SecondsToTimestamp(start) + " for " + formatNumber(duration,1u,3u,false) + " seconds:\n";
 			rstring textline = indention + phrase + "\n\n";
 			fwriteString(timeline+textline, file, error);
 			assert(error==0, "sorry, could not write to '" + filename + "', " + strerror(error)); } }
 	onPunct In: {
 		mutable int32 error = 0;
 		if (file!=0ul) {	
 		fwriteString("------------------------\t------------------------\t------------------------\n", file, error);
 		if (currentPunct()==Sys.FinalMarker) { fclose(file, error); } } }
 	} 
 
 
     // log intermediate streams when debugging
 
 //  () as Speech1Sink = FileSink(Speech1Stream) { param file: "debug.SynchronizeThreeStreams.Speech1Stream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as PunctuatedSpeech1Sink = FileSink(PunctuatedSpeech1Stream) { param file: "debug.SynchronizeThreeStreams.PunctuatedSpeech1Stream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as IndentedPunctuatedSpeech1Sink = FileSink(IndentedPunctuatedSpeech1Stream) { param file: "debug.SynchronizeThreeStreams.IndentedPunctuatedSpeech1Stream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //	() as Speech2Sink = FileSink(Speech2Stream) { param file: "debug.SynchronizeThreeStreams.Speech2Stream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as PunctuatedSpeech2Sink = FileSink(PunctuatedSpeech2Stream) { param file: "debug.SynchronizeThreeStreams.PunctuatedSpeech2Stream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as IndentedPunctuatedSpeech2Sink = FileSink(IndentedPunctuatedSpeech2Stream) { param file: "debug.SynchronizeThreeStreams.IndentedPunctuatedSpeech2Stream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as SubtitleSink = FileSink(SubtitleStream) { param file: "debug.SynchronizeThreeStreams.SubtitleStream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as PunctuatedSubtitleSink = FileSink(PunctuatedSubtitleStream) { param file: "debug.SynchronizeThreeStreams.PunctuatedSubtitleStream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as IndentedPunctuatedSubtitleSink = FileSink(IndentedPunctuatedSubtitleStream) { param file: "debug.SynchronizeThreeStreams.IndentedPunctuatedSubtitleStream.out"; format: txt; flush: 1u; writePunctuations: true; }
 //  () as SyncSink = FileSink(SynchronizedSpeech1Stream, SynchronizedSpeech2Stream, SynchronizedSubtitleStream) { param file: "debug.SynchronizeThreeStreams.SyncStreams.out"; format: txt; flush: 1u; writePunctuations: true; }
 
 
 }

   </pre>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Functions</h2>
  
</div>

<div class="section" id="spldoc_compilationunit__function__SecondsToTimestamp.float64"><h2 class="title sectiontitle splpart">rstring SecondsToTimestamp(float64 elapsed)</h2>
  
</div>
<div class="section"><h2 class="title sectiontitle">Parameters</h2>

 <ul class="sl simple">
   <li class="sli">
<strong class="ph b">elapsed</strong>
   </li>

 </ul>

</div>

<div class="section"><h2 class="title sectiontitle">Returns</h2>

<ul class="sl simple"><li class="sli">
<tt class="ph tt">rstring</tt>
</li>
</ul>

</div>

<div class="section"><h2 class="title sectiontitle splhead-2">SPL Source Code</h2>
  
</div>

<div class="section">
   <pre class="pre codeblock">

 rstring SecondsToTimestamp(float64 elapsed) { 
 	
 	int32 hours = (int32)(elapsed/3600.0);
 	int32 minutes = (int32)((elapsed-(float64)hours*3600.0)/60.0);
 	int32 seconds = (int32)(fmod(elapsed, 60.0));
 	int32 milliseconds = (int32)(fmod(elapsed, 1.0)*1000.0);
 	
 	return (rstring)minutes + ":" + 
 		   (seconds&lt;10 ? "0" : "") + (rstring)seconds + "." + 
 		   (milliseconds&lt;100 ? "0" : "") + (milliseconds&lt;10 ? "0" : "") + (rstring)milliseconds ; 
 }

   </pre>

</div>

</div>


</body>
</html>